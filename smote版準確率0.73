from imblearn.over_sampling import SMOTE 
from sklearn.preprocessing import LabelEncoder
import pandas as pd

df = pd.read_csv('seattle_weather_processed(1).csv')
df['date'] = pd.to_datetime(df['date'])

df['month']= df['date'].dt.month
df['day_of_year'] = df['date'].dt.dayofyear
df['temp_range']= df['temp_max']-df['temp_min']
df['is_snow'] = ((df['temp_min'] <= 0) & (df['precipitation'] > 0)).astype(int)
df['temp_range_3d_mean'] = df['temp_range'].rolling(window=3, min_periods=1).mean()
df['precip_3d_sum'] = df['precipitation'].rolling(window=3, min_periods=1).sum()

df['is_rainy'] = (df['precipitation'] > 0).astype(int)
df['rain_streak'] = df['is_rainy'] * (
    df['is_rainy'].groupby((df['is_rainy'] != df['is_rainy'].shift()) . cumsum()).cumcount() + 1
)

le = LabelEncoder()
df['weather_code'] = le.fit_transform(df['weather'])
classes = le.classes_

features = [
    'precipitation', 'temp_max', 'temp_min', 'wind',
    'month', 'day_of_year', 'temp_range', 'is_snow',
    'temp_range_3d_mean', 'rain_streak', 'precip_3d_sum'
]
#'is_snow','day_of_year''precip_3d_sum''temp_range_3d_mean'
X = df[features]
y = df['weather_code']

test_year = 2012
test_mask = df['date'].dt.year == test_year
train_mask = ~test_mask

X1_train = X[train_mask]
y1_train = y[train_mask]
X1_test = X[test_mask]
y1_test = y[test_mask]

smote = SMOTE(k_neighbors=3, random_state=42) 
X1_train_smote, y1_train_smote = smote.fit_resample(X1_train, y1_train)


#---------------------------------------------------
#---------------------------------------------------
#---------------------------------------------------
#模型訓練（使用 SMOTE 後的訓練資料）

import pandas as pd
# from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, recall_score, precision_score, classification_report

# 使用上半部分 SMOTE 後的訓練資料和原始測試資料
# 注意：確保特徵一致（這裡使用上半部分的 features）
X_train = X1_train_smote  # SMOTE 後的訓練特徵
y_train = y1_train_smote  # SMOTE 後的訓練標籤
X_test = X1_test           # 原始測試特徵
y_test = y1_test           # 原始測試標籤


# 建立模型（改用 Random Forest，更強大）
nb_model = RandomForestClassifier(n_estimators=100, random_state=42)
nb_model.fit(X_train, y_train)

# 預測
y_pred = nb_model.predict(X_test)

# 建立預測結果 DataFrame（使用測試資料的特徵）
pred_df = pd.DataFrame({
    'precipitation': X_test['precipitation'],
    'temp_max': X_test['temp_max'],
    'temp_min': X_test['temp_min'],
    'wind': X_test['wind'],
    'month': X_test['month'],
    'temp_range': X_test['temp_range'],
    'rain_streak': X_test['rain_streak'],
    'actual_weather': le.inverse_transform(y_test),
    'predicted_weather': le.inverse_transform(y_pred),
    'is_snow': X_test['is_snow'],
    'day_of_year': X_test['day_of_year'],  
    'temp_range_3d_mean': X_test['temp_range_3d_mean'],
    'precip_3d_sum': X_test['precip_3d_sum']
})

# 印出前20筆結果
print(pred_df.head(20))

# 計算準確率、召回率與精確率（多類別：使用 macro 平均）
accuracy = accuracy_score(y_test, y_pred)
recall = recall_score(y_test, y_pred, average='macro')
precision = precision_score(y_test, y_pred, average='macro')

# 印出評估結果：準確率、召回率及精確率
print(f"Accuracy: {accuracy:.2f}")
print(f"Recall (Macro): {recall:.2f}")
print(f"Precision (Macro): {precision:.2f}")

# 額外：印出詳細分類報告（每個類別的 precision/recall/f1）
print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=classes))
